---
title: Altworkplace Evr モバイルパフォーマンスガイド
description: さまざまな Unity プロパティを使用して、Oculus クエストなどのモバイルデバイスで世界のパフォーマンスを向上させる方法について説明します。
ms.date: 04/20/2021
ms.topic: article
keywords: ワールドエディター、パフォーマンス、oculus、quest、unity、テクスチャ、ライトマップ、stats、profiler、描画呼び出し、altアップローダー evr、
ms.openlocfilehash: d9bb02cf6c51a604b858caf36ebbc5548e4fe267
ms.sourcegitcommit: ab0ca34d20bbbcee3ce3415b17a681f8678565b7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/12/2021
ms.locfileid: "113634293"
---
# <a name="altspacevr-mobile-performance-guide"></a>Altworkplace Evr モバイルパフォーマンスガイド

## <a name="main-points"></a>**主要なポイント:**

* Oculus クエスト1と2の **72 FPS** はターゲットです。
* **静的バッチ処理による描画呼び出しの削減** が不可欠であり、25個未満の **drawcalls** を目標としています
* 静的バッチ処理を促進するために **オブジェクトごとに1つの素材**(複数の素材を持つオブジェクトを個別のオブジェクトに分割します)。
* ほとんどの場合、環境内の **オブジェクト** は **' Static '** に設定する必要があります。
* シーンごとに1つの **ライトマップ**、全シーンに1つの2k または4k、1ユニットあたり25テクテクセル、ライトマップのスケーリングはオブジェクトごとに調整する必要があります (下図の拡大縮小グラフ)
* **モバイル品質のシェーダー** (つまり、"モバイル/拡散" など) を使用します。 Unity の標準シェーダー/.Pbr/反射プローブ/ライトプローブは、負荷の高い操作であるため、プローブの場合は描画呼び出しを追加します。
* 画面上で **10 万個** 未満の三角形
* **オクルーカリング** を使用すると、画面上のポリゴンを減らすことができますが、オクルージョンカリングが有効になっているため、診断パネルを使用して、サイズフレームレートに対する影響を測定します。
* シーン内のすべての **テクスチャ** に対して、 **[Android 用に上書き** する] を使用し、[ **RGB (a)] の圧縮された astc 6x6 ブロック形式** に設定します。  Android の設定ビルドを既定値のままにしておきます (ファイル/ビルド設定/Android/テクスチャ圧縮: ' 上書きしないでください)。そのため、ライトマップが ASTC 圧縮を受けないようにします。  上記の手順を実行して、複数のオブジェクト間で資料を共有することにより、シーンの unity パッケージを **Android 用に 10-20 MB** 前後に保持しようとしています。

一般的な目標は、デバイス全体で許容可能なフレームレートにヒットすることです。 Oculus クエスト1と2では、シーンが作成されるときに、シーンがすべての視点ポイントから 72 FPS で実行されることが理想的です。ただし、60-72 FPS の範囲は、多くの場合、現実的なターゲットになります。

フレームレートは、使用している任意のデバイスの alt/Support/Show evr 内で測定できます (**設定 [Diagnostics Panel/fp**] の下にある [alt] evr アプリにあります)。

シーンの最適化を向上させるために使用できる標準的な Unity ツールのランダウン。

## <a name="stats-panelframe-debuggerprofiler"></a>**Stats パネル/フレームデバッガー/プロファイラー**

* これらのツールは、シーンのパフォーマンスを向上させるのに最適です。  シーンが再生されていないときに **のみ参照** できます (つまり、シーンが再生されていないときは自動静的バッチ処理が行われないため、これらの値はシーンの再生中には実行されません)。

* [**統計] パネル**([stats] の下のゲームビューで表示可能) には、**保存されたバッチ/バッチの量、SetPass 呼び出し、およびフレームレート** が表示されます。

    * [バッチ] –現在のカメラの視点から表示される現在の描画呼び出しの量です。  環境の **バッチが 25** 個未満の場合は、目標として適しています。
    * バッチの保存 (シーンの再生中にのみ表示) –**静的バッチまたは GPU のインスタンス** 化によって減少した描画呼び出しの量
    * SetPass Calls –シーンに表示されるさまざまな素材の数
    * フレームレート–ゲームビューでの1秒あたりのフレーム数です (何が起こっているかについてのおおよその概念を提供します。 fps の情報は常にエディター内のものとは異なるため、Oculus フレームセットパネルを使用して、常にアプリ内で、ヘッドセット内でテストする必要があります)。

* **フレームデバッガー** (ウィンドウ、分析、フレームデバッガーの下にあります)。  重きの [Stats] パネルを使用すると、GPU がどのように描画されているかを確認して最終的なイメージを作成することができます。これにより、最初から最後までの drawcalls の一覧が表示されます。  これにより、描画呼び出しが前の描画呼び出しでバッチ処理されなかった理由がわかります (つまり、' このオブジェクトは別の素材を使用します "または" このオブジェクトは別のライトマップを使用します ")。これは、シーンで起こっていること、および特定の視覚選択によって計算コストが高いのはどのよう

* **プロファイラー** では、ゲームの実行中にどの時点でどの部分が使用されているかがわかります。 パフォーマンスの bottlenecking を判断するのに役立ちます。  たとえば、シーンに大量の CPU 使用率が表示されている場合、描画呼び出しが多すぎる可能性があります。または、GPU の使用率が高い場合は、複数の透明なサーフェイスを持つことによって発生する可能性がある過剰なオーバードローが発生している可能性があります。、、またはオブジェクトがビューの外でカリングされていません。

## <a name="draw-calls-shadersmaterialsobjects"></a>**描画呼び出し (シェーダー/素材/オブジェクト)**

* シェーダー、マテリアル、またはオブジェクトをレンダリングする必要があるたびに、CPU はスイッチの GPU に指示する必要があります (' 描画呼び出し '、表現 ' **drawcalls '** とも呼ばれます)。  つまり、5個のシェーダー、10個のマテリアル、20個のオブジェクトがあり、どちらか大きい方があるとします。約20個の drawcalls があります。  Drawcalls を乗算できるその他の要因としては、オブジェクトをさまざまなライトマップに格納したり、シーンに複数のリアルタイムライトを設定したりすることがあります (つまり、あるポイントライトは、その範囲内のすべてのオブジェクトに対して別の drawcalls を追加します)。そのため、通常はシーンの指向性ライト以外の  また、リフレクションプローブとライトプローブは、ヒットしたオブジェクトに対して描画呼び出しを乗算するので、避ける必要があります。

* **静的バッチ** 処理では、GPU に送信されるときに、類似したマテリアルを共有するオブジェクトを1つのオブジェクトにバッチ処理します (非表示のメッシュは、オクルードカリングによって破棄されます)。したがって、上の例のすべてのオブジェクトを ' Static ' に設定することにより、シーンを約10個の draw 

* **素材バッチ** は、オブジェクトが別のオブジェクトとして正確なマテリアルを持っている場合に発生します。ただし、オブジェクトに複数の素材がある場合は、素材が減るオブジェクトはバッチ処理されません。  このため、オブジェクトは1つの **素材のみを持つ必要があり**、複数の素材を使用するオブジェクトは、素材ごとに個別のオブジェクトに分割する必要があります。  **テクスチャの atlasing** 使用して **素材バッチ** を減らすことができます (複数の一意のオブジェクトのテクスチャを組み合わせて1つのテクスチャシートを共有し、すべてが同じ素材を使用するようにします)。  可能であれば、Atlases の量を1つの2k または4k のテクスチャ/マテリアルに保持してください。

## <a name="scene-complexity"></a>**シーンの複雑さ**

* **Geometry** –10万未満の環境では、画面上の三角形を維持します。  Unity のゲームパネルの [Stats] タブを使用して、シーン内のさまざまな視点ポイントからどのような三角形がヒットしているかを確認します。  そのような場合は、数千のトライアングルの範囲において重要な ' ヒーロー ' のように、"数百台" の範囲内に配置する必要があります。 

* **LODs** (詳細メッシュのレベル) は技術的には使用できますが、Unity の既定のライトマップソリューションは LODs 間でライトマップデータを共有しないため、この解像度で LODs スイッチを使用すると、ライトマッピングアーティファクトを取得できます。  または、オブジェクトが低い LOD メッシュを持たない場合でも、LOD Group コンポーネントを使用して単純距離カリングを行うことができます。

![Unity の LOD Group ウィンドウ](images/world-building-lod-Group.png)

* **遮蔽カリング** によって、レンダリングされるオブジェクトの数が、カメラのビュー内でのみ表示され、すぐに表示されます (つまり、ビューから Occluded されるオブジェクトはカリングされます)。  オクルージョンカリングは、ほとんどの場合、シーンに合わせて作成する必要があります。また、レベルをサポートするように設計する必要があります (つまり、大規模な場合は、壁やラージオブジェクトを使用して、プレイヤーの視野を分割することで、常にレベルの反対側に見えないようにすることができます。  既定の焼き付ける設定は機能しますが、' 最小 Occluder ' 値または ' 最小穴 ' 値を圧縮する必要がある場合があります。  オブジェクトまたは透明なオブジェクトの亀裂によって見える可能性のあるフェンスなどのオブジェクトについては、オブジェクトの背後にあるオブジェクトが誤って occluded されないように、' Static ' ドロップダウンメニューでオブジェクトの ' Occluder ' 状態をオフにする必要があります。 

## <a name="lightmaps"></a>**ライトマップ**

* 理想的には、 **シーンごとに1つのライトマップ** (すべてに1つの2k または 4k) を使用します (そうでない場合)。解像度の高いライトマップの数が少ないほど、低解像度の多くのライトマップよりも優れています。
* また、ライトマップがあるかどうかに関係なく、複数のライトマップを持つオブジェクトは、描画呼び出しの回数に影響を与えることがあります。これは、ライトマップがあるかどうかに関係なく、他のライトマップも異なるバッチに配置されるためです。
* 一般に、 **1 ユニットあたり約25テクセル** のライトマップの解像度では十分です (照明/シーンの設定で解像度を設定します)。  ライトマップに余分なスペースがある場合は、この値を増やすことができます。
* オブジェクトごとの **ライトマップのスケーリング** 設定を変更して、必要なオブジェクトの解像度が保存されるようにします。 

* **ライトマップスケーリンググラフ** (thumb のルール) 
    * **前景** (検査 level geo): 1 
    * **Props** (特に人間よりも小さい): **2-3** (オブジェクトのライトマップアーティファクトと継ぎ目を回避するため) 
    * **Midground** (検査領域の外側、またはビルのような大きなオブジェクト): **0.5**
    * **背景** (Vista/遠く離れたオブジェクト): **0.02** 
    * **透明なサーフェイス** (ガラスなど): **0** (' Cast/Receive Shadows ' が無効) 

また、ベースラインとして、画面のドア効果の環境で使用されていた設定がいくつかあります。

![Unity の [光源] ウィンドウ](images/world-building-lightmaps.png)

注: これらの設定を使用している場合は、ライトマッパーを ' GPU ライトマッパー ' に設定し、ライトマップサイズを ' 2048 ' に設定して、プレビュー bakes を大幅に高速化することができます。その後、最終的な焼き付けるの CPU と4k にバックアップします。

## <a name="texture-compressionfile-size"></a>**テクスチャ圧縮/ファイルサイズ**

* Android のビルドでは、Unity パッケージのシーンサイズを約 10-20 MB まで維持しようとしています。  これを行うには、多くのオブジェクトで汎用的な素材を共有し、頂点の色を使用してオブジェクトを着色します。また、Android の手動オーバーライドを設定して、テクスチャが **Astc 6x6 ブロック圧縮** を使用するようにします。これは既定の圧縮よりも小さくなります。

* ASTC を使用するように Android のビルド設定が設定されていないのは、ライトマップがその圧縮 (多くのテクスチャの成果物) では適切ではなく、すべての焼き付けるの後にライトマップを使用するように設定する必要があるためです。焼き付けるごとにライトマップの圧縮設定を更新するよりも簡単です。

![Unity のテクスチャウィンドウ](images/world-building-texutres.png)

* また、2つの異方性レベルのトライリニアフィルターモードを使用するようにテクスチャを設定すると、glancing の角度でもシャープを維持するのに役立ちます。

パフォーマンスに関するヒントとテクニックについては、「 [世界のパフォーマンスの向上](improving-performance.md)」のドキュメントを参照してください。
