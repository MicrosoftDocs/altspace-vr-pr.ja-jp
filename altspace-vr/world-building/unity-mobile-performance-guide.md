---
title: Altworkplace Evr モバイルパフォーマンスガイド
description: さまざまな Unity プロパティを使用して、Oculus クエストなどのモバイルデバイスで世界のパフォーマンスを向上させる方法について説明します。
ms.date: 04/20/2021
ms.topic: article
keywords: ワールドエディター、パフォーマンス、oculus、quest、unity、テクスチャ、ライトマップ、stats、profiler、描画呼び出し、altアップローダー evr、
ms.openlocfilehash: d9bb02cf6c51a604b858caf36ebbc5548e4fe267
ms.sourcegitcommit: ab0ca34d20bbbcee3ce3415b17a681f8678565b7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/12/2021
ms.locfileid: "113634293"
---
# <a name="altspacevr-mobile-performance-guide"></a><span data-ttu-id="4630f-104">Altworkplace Evr モバイルパフォーマンスガイド</span><span class="sxs-lookup"><span data-stu-id="4630f-104">AltspaceVR Mobile Performance Guide</span></span>

## <a name="main-points"></a><span data-ttu-id="4630f-105">**主要なポイント:**</span><span class="sxs-lookup"><span data-stu-id="4630f-105">**Main Points:**</span></span>

* <span data-ttu-id="4630f-106">Oculus クエスト1と2の **72 FPS** はターゲットです。</span><span class="sxs-lookup"><span data-stu-id="4630f-106">**72 FPS** on Oculus Quest 1 and 2, is the target.</span></span>
* <span data-ttu-id="4630f-107">**静的バッチ処理による描画呼び出しの削減** が不可欠であり、25個未満の **drawcalls** を目標としています</span><span class="sxs-lookup"><span data-stu-id="4630f-107">**Reducing Draw Calls via Static Batching** is essential, aim for **less than 25 drawcalls**</span></span>
* <span data-ttu-id="4630f-108">静的バッチ処理を促進するために **オブジェクトごとに1つの素材**(複数の素材を持つオブジェクトを個別のオブジェクトに分割します)。</span><span class="sxs-lookup"><span data-stu-id="4630f-108">**One material per object** to encourage Static Batching (split up multi-material objects into separate objects).</span></span>
* <span data-ttu-id="4630f-109">ほとんどの場合、環境内の **オブジェクト** は **' Static '** に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-109">**Objects** in an environment should be set to **‘Static’** in most cases.</span></span>
* <span data-ttu-id="4630f-110">シーンごとに1つの **ライトマップ**、全シーンに1つの2k または4k、1ユニットあたり25テクテクセル、ライトマップのスケーリングはオブジェクトごとに調整する必要があります (下図の拡大縮小グラフ)</span><span class="sxs-lookup"><span data-stu-id="4630f-110">**One lightmap per scene**, one 2k or one 4k for the whole scene, ~25 texels per unit, lightmap scaling should be tuned per object (scaling chart below)</span></span>
* <span data-ttu-id="4630f-111">**モバイル品質のシェーダー** (つまり、"モバイル/拡散" など) を使用します。 Unity の標準シェーダー/.Pbr/反射プローブ/ライトプローブは、負荷の高い操作であるため、プローブの場合は描画呼び出しを追加します。</span><span class="sxs-lookup"><span data-stu-id="4630f-111">**Use Mobile-quality shaders** (that is, ‘Mobile/Diffuse’, etc.), avoid the Unity Standard shader/PBR/Reflection Probes/Light Probes as they are heavy operations and in the case of the probes will add draw calls.</span></span>
* <span data-ttu-id="4630f-112">画面上で **10 万個** 未満の三角形</span><span class="sxs-lookup"><span data-stu-id="4630f-112">**Less than 100k triangles** on-screen</span></span>
* <span data-ttu-id="4630f-113">**オクルーカリング** を使用すると、画面上のポリゴンを減らすことができますが、オクルージョンカリングが有効になっているため、診断パネルを使用して、サイズフレームレートに対する影響を測定します。</span><span class="sxs-lookup"><span data-stu-id="4630f-113">**Occlusion Culling** can help reduce on-screen polygons, although there is an up-front cost to having occlusion culling enabled so measure the effect on framerate in Altspace using the Diagnostics Panel.</span></span>
* <span data-ttu-id="4630f-114">シーン内のすべての **テクスチャ** に対して、 **[Android 用に上書き** する] を使用し、[ **RGB (a)] の圧縮された astc 6x6 ブロック形式** に設定します。</span><span class="sxs-lookup"><span data-stu-id="4630f-114">For all **textures** in a scene, use **‘Override for Android’** and set them to **RGB(A) Compressed ASTC 6x6 block format**.</span></span>  <span data-ttu-id="4630f-115">Android の設定ビルドを既定値のままにしておきます (ファイル/ビルド設定/Android/テクスチャ圧縮: ' 上書きしないでください)。そのため、ライトマップが ASTC 圧縮を受けないようにします。</span><span class="sxs-lookup"><span data-stu-id="4630f-115">Leave your Android Build Settings compression to default (found in: File/Build Settings/Android/Texture Compression: ‘Don’t override’), so that Lightmaps don’t get ASTC compression.</span></span>  <span data-ttu-id="4630f-116">上記の手順を実行して、複数のオブジェクト間で資料を共有することにより、シーンの unity パッケージを **Android 用に 10-20 MB** 前後に保持しようとしています。</span><span class="sxs-lookup"><span data-stu-id="4630f-116">By doing the above, and by sharing materials across objects, we try to keep our scene’s unity package to around **10-20 MB for Android**.</span></span>

<span data-ttu-id="4630f-117">一般的な目標は、デバイス全体で許容可能なフレームレートにヒットすることです。 Oculus クエスト1と2では、シーンが作成されるときに、シーンがすべての視点ポイントから 72 FPS で実行されることが理想的です。ただし、60-72 FPS の範囲は、多くの場合、現実的なターゲットになります。</span><span class="sxs-lookup"><span data-stu-id="4630f-117">The general goal is to hit an acceptable framerate across devices – on Oculus Quest 1 and 2 ideally the scene will run at 72 FPS from all vantage points when the scene is populated, although a range of 60-72 FPS is often a more realistic target.</span></span>

<span data-ttu-id="4630f-118">フレームレートは、使用している任意のデバイスの alt/Support/Show evr 内で測定できます (**設定 [Diagnostics Panel/fp**] の下にある [alt] evr アプリにあります)。</span><span class="sxs-lookup"><span data-stu-id="4630f-118">Framerate can be measured within AltspaceVR on whichever device that you’re using (found in the AltspaceVR app under **Settings/Support/Show Diagnostics Panel/FPS**).</span></span>

<span data-ttu-id="4630f-119">シーンの最適化を向上させるために使用できる標準的な Unity ツールのランダウン。</span><span class="sxs-lookup"><span data-stu-id="4630f-119">A rundown of the standard Unity tools available to help you to better-optimize your scenes:</span></span>

## <a name="stats-panelframe-debuggerprofiler"></a><span data-ttu-id="4630f-120">**Stats パネル/フレームデバッガー/プロファイラー**</span><span class="sxs-lookup"><span data-stu-id="4630f-120">**Stats Panel/Frame Debugger/Profiler**</span></span>

* <span data-ttu-id="4630f-121">これらのツールは、シーンのパフォーマンスを向上させるのに最適です。</span><span class="sxs-lookup"><span data-stu-id="4630f-121">These tools will be your best friends in improving your scene's performance.</span></span>  <span data-ttu-id="4630f-122">シーンが再生されていないときに **のみ参照** できます (つまり、シーンが再生されていないときは自動静的バッチ処理が行われないため、これらの値はシーンの再生中には実行されません)。</span><span class="sxs-lookup"><span data-stu-id="4630f-122">They can **only be referenced while the scene is Playing in-editor**, as their values will be different from when the scene is not playing (that is, Automatic static batching won't be happening when the scene isn't playing)</span></span>

* <span data-ttu-id="4630f-123">[**統計] パネル**([stats] の下のゲームビューで表示可能) には、**保存されたバッチ/バッチの量、SetPass 呼び出し、およびフレームレート** が表示されます。</span><span class="sxs-lookup"><span data-stu-id="4630f-123">**Stats Panel** (viewable in Game View under 'Stats') will show you the amount of **Batches/Batches Saved, SetPass Calls, and Framerate**.</span></span>

    * <span data-ttu-id="4630f-124">[バッチ] –現在のカメラの視点から表示される現在の描画呼び出しの量です。</span><span class="sxs-lookup"><span data-stu-id="4630f-124">Batches – the amount of current draw calls that are visible from the current camera's perspective.</span></span>  <span data-ttu-id="4630f-125">環境の **バッチが 25** 個未満の場合は、目標として適しています。</span><span class="sxs-lookup"><span data-stu-id="4630f-125">**Fewer than 25 batches** for an environment is a good target to aim for.</span></span>
    * <span data-ttu-id="4630f-126">バッチの保存 (シーンの再生中にのみ表示) –**静的バッチまたは GPU のインスタンス** 化によって減少した描画呼び出しの量</span><span class="sxs-lookup"><span data-stu-id="4630f-126">Batches Saved (only visible when the scene is Playing)  – the amount draw calls that have been reduced via **Static Batching or GPU Instancing**</span></span>
    * <span data-ttu-id="4630f-127">SetPass Calls –シーンに表示されるさまざまな素材の数</span><span class="sxs-lookup"><span data-stu-id="4630f-127">SetPass Calls – the number of different visible materials in a scene</span></span>
    * <span data-ttu-id="4630f-128">フレームレート–ゲームビューでの1秒あたりのフレーム数です (何が起こっているかについてのおおよその概念を提供します。 fps の情報は常にエディター内のものとは異なるため、Oculus フレームセットパネルを使用して、常にアプリ内で、ヘッドセット内でテストする必要があります)。</span><span class="sxs-lookup"><span data-stu-id="4630f-128">Framerate – the amount of frames-per-second in the Game view (gives you an approximate idea of what's happening; scenes should always be tested in-app, in-headset, using the Oculus Framerate panel as the fps readout will always be different than what's in-editor)</span></span>

* <span data-ttu-id="4630f-129">**フレームデバッガー** (ウィンドウ、分析、フレームデバッガーの下にあります)。</span><span class="sxs-lookup"><span data-stu-id="4630f-129">**Frame Debugger** (found under Window/Analysis/Frame Debugger).</span></span>  <span data-ttu-id="4630f-130">重きの [Stats] パネルを使用すると、GPU がどのように描画されているかを確認して最終的なイメージを作成することができます。これにより、最初から最後までの drawcalls の一覧が表示されます。</span><span class="sxs-lookup"><span data-stu-id="4630f-130">The Stats Panel on steroids that, when enabled, will allow you to see what the GPU is drawing to create the final image, showing you a list of drawcalls from first to last.</span></span>  <span data-ttu-id="4630f-131">これにより、描画呼び出しが前の描画呼び出しでバッチ処理されなかった理由がわかります (つまり、' このオブジェクトは別の素材を使用します "または" このオブジェクトは別のライトマップを使用します ")。これは、シーンで起こっていること、および特定の視覚選択によって計算コストが高いのはどのよう</span><span class="sxs-lookup"><span data-stu-id="4630f-131">It will give you reasons for why a draw call wasn't batched with a previous draw call (that is, 'This object uses a different Material' or 'This object uses a different Lightmap'), and is an excellent way towards developing an understanding both of what's happening in your scene, and how and why certain visual choices can be computationally expensive.</span></span>

* <span data-ttu-id="4630f-132">**プロファイラー** では、ゲームの実行中にどの時点でどの部分が使用されているかがわかります。</span><span class="sxs-lookup"><span data-stu-id="4630f-132">**Profiler** will show you what parts of the computer are being used at any point in time while the game is running.</span></span> <span data-ttu-id="4630f-133">パフォーマンスの bottlenecking を判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4630f-133">Helpful in determining where performance is bottlenecking.</span></span>  <span data-ttu-id="4630f-134">たとえば、シーンに大量の CPU 使用率が表示されている場合、描画呼び出しが多すぎる可能性があります。または、GPU の使用率が高い場合は、複数の透明なサーフェイスを持つことによって発生する可能性がある過剰なオーバードローが発生している可能性があります。、、またはオブジェクトがビューの外でカリングされていません。</span><span class="sxs-lookup"><span data-stu-id="4630f-134">For instance, if you are seeing heavy CPU usage in your scene, it could be that there are too many draw calls, or if you're seeing heavy GPU usage, there might be too much overdraw happening (that is, the number of times that a single pixel is rendered to produce the final image) which can be caused by having multiple transparent surfaces, or objects not being culled when out of view.</span></span>

## <a name="draw-calls-shadersmaterialsobjects"></a><span data-ttu-id="4630f-135">**描画呼び出し (シェーダー/素材/オブジェクト)**</span><span class="sxs-lookup"><span data-stu-id="4630f-135">**Draw Calls (Shaders/Materials/Objects)**</span></span>

* <span data-ttu-id="4630f-136">シェーダー、マテリアル、またはオブジェクトをレンダリングする必要があるたびに、CPU はスイッチの GPU に指示する必要があります (' 描画呼び出し '、表現 ' **drawcalls '** とも呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="4630f-136">Every time that a shader, material or object needs to be rendered, the CPU has to instruct the GPU of the switch (also known as 'draw calls', colloquially **'drawcalls'**).</span></span>  <span data-ttu-id="4630f-137">つまり、5個のシェーダー、10個のマテリアル、20個のオブジェクトがあり、どちらか大きい方があるとします。約20個の drawcalls があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-137">That is, if you have 5 shaders, 10 materials, and 20 objects, with whichever is greatest; you'll have approximately 20 drawcalls.</span></span>  <span data-ttu-id="4630f-138">Drawcalls を乗算できるその他の要因としては、オブジェクトをさまざまなライトマップに格納したり、シーンに複数のリアルタイムライトを設定したりすることがあります (つまり、あるポイントライトは、その範囲内のすべてのオブジェクトに対して別の drawcalls を追加します)。そのため、通常はシーンの指向性ライト以外の</span><span class="sxs-lookup"><span data-stu-id="4630f-138">Other things that can multiply drawcalls include having objects on different lightmaps or having more than one real-time light in a scene (that is, one point light will add another drawcall to every object that is within its range), so generally anything other than a scene's directional light should be avoided.</span></span>  <span data-ttu-id="4630f-139">また、リフレクションプローブとライトプローブは、ヒットしたオブジェクトに対して描画呼び出しを乗算するので、避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-139">Reflection probes and light probes will also multiply draw calls on whichever objects that they hit, so they should be avoided.</span></span>

* <span data-ttu-id="4630f-140">**静的バッチ** 処理では、GPU に送信されるときに、類似したマテリアルを共有するオブジェクトを1つのオブジェクトにバッチ処理します (非表示のメッシュは、オクルードカリングによって破棄されます)。したがって、上の例のすべてのオブジェクトを ' Static ' に設定することにより、シーンを約10個の draw</span><span class="sxs-lookup"><span data-stu-id="4630f-140">**Static Batching** will batch objects that share like-materials into a single object when sent to the GPU (with Occlusion Culling discarding meshes that are out of view), so by setting all objects in the above example to 'Static', you would reduce the scene to approximately 10 drawcalls, 1 for every material.</span></span> 

* <span data-ttu-id="4630f-141">**素材バッチ** は、オブジェクトが別のオブジェクトとして正確なマテリアルを持っている場合に発生します。ただし、オブジェクトに複数の素材がある場合は、素材が減るオブジェクトはバッチ処理されません。</span><span class="sxs-lookup"><span data-stu-id="4630f-141">**Material batches** occur when an object has the exact materials as another object, however if an object has multiple materials, it won't batch with an object that has fewer materials.</span></span>  <span data-ttu-id="4630f-142">このため、オブジェクトは1つの **素材のみを持つ必要があり**、複数の素材を使用するオブジェクトは、素材ごとに個別のオブジェクトに分割する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-142">For this reason: **Objects MUST only have 1 material**, and objects that use several materials should be split into separate objects per material.</span></span>  <span data-ttu-id="4630f-143">**テクスチャの atlasing** 使用して **素材バッチ** を減らすことができます (複数の一意のオブジェクトのテクスチャを組み合わせて1つのテクスチャシートを共有し、すべてが同じ素材を使用するようにします)。</span><span class="sxs-lookup"><span data-stu-id="4630f-143">**Material batches** can be reduced through **Texture Atlasing** (combining multiple unique object's textures to share a single texture sheet so that they all use the same material).</span></span>  <span data-ttu-id="4630f-144">可能であれば、Atlases の量を1つの2k または4k のテクスチャ/マテリアルに保持してください。</span><span class="sxs-lookup"><span data-stu-id="4630f-144">Try to keep the amount of Atlases down to a single 2k or 4k texture/material per scene if possible.</span></span>

## <a name="scene-complexity"></a><span data-ttu-id="4630f-145">**シーンの複雑さ**</span><span class="sxs-lookup"><span data-stu-id="4630f-145">**Scene Complexity**</span></span>

* <span data-ttu-id="4630f-146">**Geometry** –10万未満の環境では、画面上の三角形を維持します。</span><span class="sxs-lookup"><span data-stu-id="4630f-146">**Geometry** – try to keep onscreen triangles for environments below 100k.</span></span>  <span data-ttu-id="4630f-147">Unity のゲームパネルの [Stats] タブを使用して、シーン内のさまざまな視点ポイントからどのような三角形がヒットしているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="4630f-147">Use the ‘Stats’ tab in Unity’s Game panel to see what triangle counts you’re hitting from various vantage points in the scene.</span></span>  <span data-ttu-id="4630f-148">そのような場合は、数千のトライアングルの範囲において重要な ' ヒーロー ' のように、"数百台" の範囲内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-148">Props as such should be in the ‘hundreds’ of triangles range, with only important ‘hero’ props in the thousands of triangles range.</span></span> 

* <span data-ttu-id="4630f-149">**LODs** (詳細メッシュのレベル) は技術的には使用できますが、Unity の既定のライトマップソリューションは LODs 間でライトマップデータを共有しないため、この解像度で LODs スイッチを使用すると、ライトマッピングアーティファクトを取得できます。</span><span class="sxs-lookup"><span data-stu-id="4630f-149">You can technically use **LODs** (level of detail meshes), although Unity’s default lightmap solution does not share lightmap data between LODs, so you may get lightmapping artifacts when the LODs switch at this resolution.</span></span>  <span data-ttu-id="4630f-150">または、オブジェクトが低い LOD メッシュを持たない場合でも、LOD Group コンポーネントを使用して単純距離カリングを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="4630f-150">Alternatively, you can use the LOD Group component for simple Distance Culling, even if the object doesn’t have lower LOD meshes:</span></span>

![Unity の LOD Group ウィンドウ](images/world-building-lod-Group.png)

* <span data-ttu-id="4630f-152">**遮蔽カリング** によって、レンダリングされるオブジェクトの数が、カメラのビュー内でのみ表示され、すぐに表示されます (つまり、ビューから Occluded されるオブジェクトはカリングされます)。</span><span class="sxs-lookup"><span data-stu-id="4630f-152">**Occlusion Culling** reduces the number of objects that are rendered to only what is within the camera's view frustum, and that are immediately visible (that is, objects that are Occluded from view are Culled).</span></span>  <span data-ttu-id="4630f-153">オクルージョンカリングは、ほとんどの場合、シーンに合わせて作成する必要があります。また、レベルをサポートするように設計する必要があります (つまり、大規模な場合は、壁やラージオブジェクトを使用して、プレイヤーの視野を分割することで、常にレベルの反対側に見えないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4630f-153">Occlusion culling should almost always be baked for your scene, and levels should be designed to support it (that is, if you have a large level, walls or large objects can be used to break up the player's line-of-sight, so that they can't always see through to the opposite end of the level.</span></span>  <span data-ttu-id="4630f-154">既定の焼き付ける設定は機能しますが、' 最小 Occluder ' 値または ' 最小穴 ' 値を圧縮する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-154">The default bake settings should work, although you may have to shrink the 'Smallest Occluder' or 'Smallest Hole' values.</span></span>  <span data-ttu-id="4630f-155">オブジェクトまたは透明なオブジェクトの亀裂によって見える可能性のあるフェンスなどのオブジェクトについては、オブジェクトの背後にあるオブジェクトが誤って occluded されないように、' Static ' ドロップダウンメニューでオブジェクトの ' Occluder ' 状態をオフにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4630f-155">For objects like fences where you may be able to see through cracks in the object, or transparent objects, you should turn off the object's 'Occluder' status in the 'Static' drop-down menu so that objects behind it aren't erroneously occluded.</span></span> 

## <a name="lightmaps"></a><span data-ttu-id="4630f-156">**ライトマップ**</span><span class="sxs-lookup"><span data-stu-id="4630f-156">**Lightmaps**</span></span>

* <span data-ttu-id="4630f-157">理想的には、 **シーンごとに1つのライトマップ** (すべてに1つの2k または 4k) を使用します (そうでない場合)。解像度の高いライトマップの数が少ないほど、低解像度の多くのライトマップよりも優れています。</span><span class="sxs-lookup"><span data-stu-id="4630f-157">Ideally just **one lightmap per scene** (one 2k or one 4k for everything), if not; fewer lightmaps of higher resolutions are better than many lightmaps of lower resolutions.</span></span>
* <span data-ttu-id="4630f-158">また、ライトマップがあるかどうかに関係なく、複数のライトマップを持つオブジェクトは、描画呼び出しの回数に影響を与えることがあります。これは、ライトマップがあるかどうかに関係なく、他のライトマップも異なるバッチに配置されるためです。</span><span class="sxs-lookup"><span data-stu-id="4630f-158">Having multiple lightmaps can also affect the number of draw calls, as objects that either have or don't have lightmaps will be on different batches, and other lightmaps will also be on different batches.</span></span>
* <span data-ttu-id="4630f-159">一般に、 **1 ユニットあたり約25テクセル** のライトマップの解像度では十分です (照明/シーンの設定で解像度を設定します)。</span><span class="sxs-lookup"><span data-stu-id="4630f-159">Generally, a Lightmap Resolution of around **25 texels per unit** should suffice (set resolution in the Lighting/Scene settings).</span></span>  <span data-ttu-id="4630f-160">ライトマップに余分なスペースがある場合は、この値を増やすことができます。</span><span class="sxs-lookup"><span data-stu-id="4630f-160">If you have extra room in your lightmap, you can increase this value.</span></span>
* <span data-ttu-id="4630f-161">オブジェクトごとの **ライトマップのスケーリング** 設定を変更して、必要なオブジェクトの解像度が保存されるようにします。</span><span class="sxs-lookup"><span data-stu-id="4630f-161">Change the **Lightmap Scaling** setting per object so that the resolution is saved for objects that need it.</span></span> 

* <span data-ttu-id="4630f-162">**ライトマップスケーリンググラフ** (thumb のルール)</span><span class="sxs-lookup"><span data-stu-id="4630f-162">**Lightmap Scaling Chart** (rule of thumb)</span></span> 
    * <span data-ttu-id="4630f-163">**前景** (検査 level geo): 1</span><span class="sxs-lookup"><span data-stu-id="4630f-163">**Foreground** (Traversable level geo): 1</span></span> 
    * <span data-ttu-id="4630f-164">**Props** (特に人間よりも小さい): **2-3** (オブジェクトのライトマップアーティファクトと継ぎ目を回避するため)</span><span class="sxs-lookup"><span data-stu-id="4630f-164">**Props** (especially props smaller than a human): **2-3** (to avoid lightmap artifacts and seams on your objects)</span></span> 
    * <span data-ttu-id="4630f-165">**Midground** (検査領域の外側、またはビルのような大きなオブジェクト): **0.5**</span><span class="sxs-lookup"><span data-stu-id="4630f-165">**Midground** (Geometry that is just outside of the traversable area and/or large objects like buildings): **0.5**</span></span>
    * <span data-ttu-id="4630f-166">**背景** (Vista/遠く離れたオブジェクト): **0.02**</span><span class="sxs-lookup"><span data-stu-id="4630f-166">**Background** (Vista/distant objects): **0.02**</span></span> 
    * <span data-ttu-id="4630f-167">**透明なサーフェイス** (ガラスなど): **0** (' Cast/Receive Shadows ' が無効)</span><span class="sxs-lookup"><span data-stu-id="4630f-167">**Transparent Surfaces** (like glass): **0** (with 'Cast/Receive Shadows’ disabled)</span></span> 

<span data-ttu-id="4630f-168">また、ベースラインとして、画面のドア効果の環境で使用されていた設定がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="4630f-168">Also, as a baseline, here are some settings that were used for the Screen Door Effect environment:</span></span>

![Unity の [光源] ウィンドウ](images/world-building-lightmaps.png)

<span data-ttu-id="4630f-170">注: これらの設定を使用している場合は、ライトマッパーを ' GPU ライトマッパー ' に設定し、ライトマップサイズを ' 2048 ' に設定して、プレビュー bakes を大幅に高速化することができます。その後、最終的な焼き付けるの CPU と4k にバックアップします。</span><span class="sxs-lookup"><span data-stu-id="4630f-170">Note: If you are using these settings, you can set the Lightmapper to 'GPU Lightmapper' and set the Lightmap Size to '2048' for much faster preview bakes, and then back up to CPU and 4k for your final bake.</span></span>

## <a name="texture-compressionfile-size"></a><span data-ttu-id="4630f-171">**テクスチャ圧縮/ファイルサイズ**</span><span class="sxs-lookup"><span data-stu-id="4630f-171">**Texture Compression/File Size**</span></span>

* <span data-ttu-id="4630f-172">Android のビルドでは、Unity パッケージのシーンサイズを約 10-20 MB まで維持しようとしています。</span><span class="sxs-lookup"><span data-stu-id="4630f-172">For our Android build, we try to keep our Unity package scene size down to around 10-20 MB total.</span></span>  <span data-ttu-id="4630f-173">これを行うには、多くのオブジェクトで汎用的な素材を共有し、頂点の色を使用してオブジェクトを着色します。また、Android の手動オーバーライドを設定して、テクスチャが **Astc 6x6 ブロック圧縮** を使用するようにします。これは既定の圧縮よりも小さくなります。</span><span class="sxs-lookup"><span data-stu-id="4630f-173">We do this by sharing generic materials across many objects, using vertex color to tint the objects, and also by setting manual overrides for Android so that textures use **ASTC 6x6 block compression**, which will be smaller than the default compression.</span></span>

* <span data-ttu-id="4630f-174">ASTC を使用するように Android のビルド設定が設定されていないのは、ライトマップがその圧縮 (多くのテクスチャの成果物) では適切ではなく、すべての焼き付けるの後にライトマップを使用するように設定する必要があるためです。焼き付けるごとにライトマップの圧縮設定を更新するよりも簡単です。</span><span class="sxs-lookup"><span data-stu-id="4630f-174">The reason that we don't set the Android build settings to use ASTC is because lightmaps do not look good with that compression (lots of blocky artifacts), and we’d have to set the lightmap to use ETC after every bake, so it is easier instead to set up the override for all scene textures once than it is to update the lightmap’s compression settings after every bake.</span></span>

![Unity のテクスチャウィンドウ](images/world-building-texutres.png)

* <span data-ttu-id="4630f-176">また、2つの異方性レベルのトライリニアフィルターモードを使用するようにテクスチャを設定すると、glancing の角度でもシャープを維持するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4630f-176">Also, setting Textures to use Trilinear Filter Mode with a 2 Anisotropic Level can help them remain sharp at glancing angles.</span></span>

<span data-ttu-id="4630f-177">パフォーマンスに関するヒントとテクニックについては、「 [世界のパフォーマンスの向上](improving-performance.md)」のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4630f-177">More performance tips and tricks can be found in the [Improving world performance documentation](improving-performance.md).</span></span>
