---
title: AltspaceVR モバイル パフォーマンス ガイド
description: さまざまな Unity プロパティを使用して、Oculus Quest のようなモバイル デバイスで世界のパフォーマンスを高める方法について学習します
ms.date: 04/20/2021
ms.topic: article
keywords: ワールド エディター, パフォーマンス, oculus, quest, unity, テクスチャ, ライトマップ, 統計, プロファイラー, 描画呼び出し, altspacevr, アップデータ
ms.openlocfilehash: d5689e245c10ccb61abdd0aaa2327132d4374bb7e53a2eaec316d991b38378fb
ms.sourcegitcommit: b248ba2a6da7d669b430581fc3a1544413b2e9c1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/11/2021
ms.locfileid: "119126978"
---
# <a name="altspacevr-mobile-performance-guide"></a>AltspaceVR モバイル パフォーマンス ガイド

## <a name="main-points"></a>**主なポイント:**

* Oculus Quest 1 および 2 の **72 FPS** がターゲットです。
* **静的バッチ処理による描画呼び出し** の削減は不可欠です **。25 未満の描画コールを目指します**
* **静的バッチ処理を促進するために** 、オブジェクトごとに 1 つのマテリアル (マルチマテリアル オブジェクトを個別のオブジェクトに分割する)。
* **ほとんどの** 場合、環境内のオブジェクトは **'Static'** に設定する必要があります。
* **シーンごとに** 1 つのライトマップ、シーン全体に対して 1 つの 2K または 1 つの 4k、ユニットあたり約 25 のテセル、ライトマップのスケーリングはオブジェクトごとに調整する必要があります (下のスケーリング チャート)
* モバイル **品質** のシェーダー (つまり、"モバイル/拡散") を使用し、Unity 標準シェーダー/PBR/リフレクション プローブ/ライト プローブは操作が多く、プローブの場合は描画呼び出しが追加されます。
* **画面の三角形が 100,000** 未満
* **オ** クルージョン カリングは画面の多角形を減らすのに役立ちますが、オクルージョン カリングを有効にした場合にコストがかかるので、診断パネルを使用して Altspace のフレームレートへの影響を測定します。
* シーン内 **のすべてのテクスチャに** 対して **、"Override for Android"** を使用し、 **それらを RGB(A) Compressed ASTC 6x6 ブロック形式に設定します**。  Android Build 設定 の圧縮は既定値のままにします (ファイル/ビルド 設定/Android/テクスチャ圧縮: 'オーバーライドしない') の場合、ライトマップで ASTC 圧縮が取得されません。  上記を行い、オブジェクト間で素材を共有することで、シーンの Unity パッケージを Android 用 **の約 10 ~ 20 MB に維持します**。

一般的な目標は、デバイス全体で許容可能なフレームレートにヒットする方法です。Oculus Quest 1 と 2 では、シーンが設定されているときに、シーンがすべての見上げポイントから 72 FPS で実行されるのが理想的ですが、60 から 72 FPS の範囲は、多くの場合、より現実的なターゲットです。

フレームレートは、使用しているデバイスの AltspaceVR 内で測定できます **(設定/Support/Show Diagnostics Panel/FPS** の下にある AltspaceVR アプリで確認できます)。

シーンの最適化に役立つ標準の Unity ツールのランダウン:

## <a name="stats-panelframe-debuggerprofiler"></a>**統計パネル/フレーム デバッガー/プロファイラー**

* これらのツールは、シーンのパフォーマンスを向上させるのに最適な友人です。  これらは、 **シーン** がエディター内で再生されている間にのみ参照できます。これは、シーンが再生されていないときとは値が異なる (つまり、シーンが再生されていないときに自動静的バッチ処理が実行されない) ので、

* **統計パネル** ([統計] の下のゲーム ビューで表示可能) には、保存されたバッチ/バッチの量、SetPass 呼び出し、 **および Framerate が表示されます**。

    * バッチ – 現在のカメラの観点から見た現在の描画呼び出しの量。  **環境のバッチ数が 25** 未満の場合は、目標とするのが良いターゲットです。
    * 保存されたバッチ (シーンが再生中の場合にのみ表示) – 静的バッチ処理または **GPU** インスタンス化によって削減された描画呼び出しの量
    * SetPass 呼び出し – シーン内の異なる表示されるマテリアルの数
    * Framerate – ゲーム ビューの 1 秒あたりのフレームの量 (何が起こっているかを概念的に理解できます。シーンは常に、Oculus Framerate パネルを使用してアプリ内でテストする必要があります。Fps の読み取りはエディター内の読み取りとは常に異なります)

* **フレーム デバッガー** ([ウィンドウ]/[分析]/[フレーム デバッガー]) の下に表示されます。  有効にすると、GPU が描画している画像を確認して最終的なイメージを作成し、最初から最後まで描画の一覧を表示できる、上の統計パネル。  描画呼び出しが以前の描画呼び出しでバッチ処理されていない理由 (つまり、"このオブジェクトは別の素材を使用しています" または "このオブジェクトは別の Lightmap を使用しています") が得られるので、シーンで何が起こっているか、および特定のビジュアルの選択が計算コストになる方法と理由の両方を理解するための優れた方法です。

* **プロファイラー** には、ゲームの実行中に、任意の時点でコンピューターの使用されている部分が表示されます。 パフォーマンスがボトルネックとなっている場所を特定する際に役立ちます。  たとえば、シーンで CPU 使用率が高い場合、描画呼び出しが多すぎる可能性があります。また、GPU 使用率が高い場合は、過剰なオーバー描画が発生する可能性があります (つまり、1 ピクセルがレンダリングされ、最終的なイメージが生成される回数)。 または オブジェクトは、ビューから外れたときにカリングされません。

## <a name="draw-calls-shadersmaterialsobjects"></a>**描画呼び出し (シェーダー/素材/オブジェクト)**

* シェーダー、素材、またはオブジェクトをレンダリングする必要があるたび、CPU はスイッチの GPU に指示する必要があります ("描画呼び出し"、口語的には **"drawcalls"** とも呼ばれています)。  つまり、シェーダーが 5 つ、素材が 10、オブジェクトが 20 の場合は、どちらが最も大きい方になります。描画スケールは約 20 です。  描画コールを乗算できるその他の点としては、異なるライトマップ上にオブジェクトを含めるか、シーン内に複数のリアルタイムライトを含める (つまり、1 つの点光によって、その範囲内にあるすべてのオブジェクトに別の描画コールが追加される) ことが含まれるので、一般にシーンの指向性ライト以外のものは避ける必要があります。  リフレクション プローブとライト プローブでは、ヒットしたオブジェクトに対する描画呼び出しも乗算されます。そのため、回避する必要があります。

* 静的バッチ処理では、GPU に送信された場合に、同じ素材を共有するオブジェクトを 1 つのオブジェクトにバッチ処理します (Occlusion Culling では、ビュー外のメッシュが破棄されます)。そのため、上の例のすべてのオブジェクトを "Static" に設定することで、シーンを約 10 の描画スケール (素材ごとに 1) に減らします。 

* **素材バッチは** 、オブジェクトに別のオブジェクトとまったく同じ素材がある場合に発生しますが、オブジェクトに複数の素材がある場合、素材が少ないオブジェクトでバッチ処理は行われません。  このため、オブジェクトには **1** つの素材のみを含め、複数の素材を使用するオブジェクトは、素材ごとに個別のオブジェクトに分割する必要があります。  **素材バッチは** 、 **テクスチャ Atlasing** を使用して削減できます (複数の一意のオブジェクトのテクスチャを組み合わせて 1 つのテクスチャ シートを共有し、すべてが同じマテリアルを使用します)。  可能であれば、Atlases の量をシーンごとに 1 つの 2k または 4k のテクスチャ/マテリアルに減らしてみてください。

## <a name="scene-complexity"></a>**シーンの複雑さ**

* **Geometry** – 環境の画面上の三角形を 100,000 以下に保ちます。  Unity の [ゲーム] パネルの [統計] タブを使用して、シーン内のさまざまな見えるポイントからヒットしている三角形のカウントを確認します。  このような Prop は、数百の三角形の範囲に含む必要があります。重要な 'hero' props は、数千の三角形の範囲に含む必要があります。 

* 技術的には **LOD** (詳細メッシュのレベル) を使用できます。ただし、Unity の既定のライトマップ ソリューションは LOD 間でライトマップ データを共有しないので、この解像度で LOD が切り替えるときにライトマップアーティファクトを取得できます。  または、オブジェクトの LOD メッシュが低い場合でも、単純な距離カリングに LOD グループ コンポーネントを使用できます。

![Unity の LOD グループ ウィンドウ](images/world-building-lod-Group.png)

* **オクルー** ジョン カリングを使用すると、カメラのビューの frustum 内にあるものにのみレンダリングされ、すぐに表示されるオブジェクト (つまり、ビューからオクルードされたオブジェクトは Culled) にレンダリングされるオブジェクトの数が減ります。  オクルージョン カリングは、ほとんどの場合、シーン用にベイクする必要があります。また、それをサポートするようにレベルを設計する必要があります (つまり、大きなレベルの場合、壁や大きなオブジェクトを使用してプレーヤーの視線を分け、常にレベルの反対側の端まで見抜け出す必要はありません)。  既定のベイク設定は機能しますが、'Smallest Occluder' または 'Smallest Hole' の値を縮小する必要がある場合があります。  オブジェクトの割れ目を確認できる可能性があるフェンスや透明なオブジェクトのようなオブジェクトの場合は、[静的] ドロップダウン メニューでオブジェクトの 'Occluder' 状態をオフにし、背後にあるオブジェクトが誤って隠れ込むのを防ぐことが必要です。 

## <a name="lightmaps"></a>**ライトマップ**

* ない場合は **、シーンごとに 1** つのライトマップ (1 つの 2k または 1 つの 4k) が理想的です。より低い解像度の多くのライトマップよりも、より高い解像度のライトマップが少ない方が優れたものになっています。
* 複数のライトマップを使用すると、描画呼び出しの数にも影響を与える可能性があります。ライトマップを持つオブジェクトまたはないオブジェクトは異なるバッチ上に表示され、他のライトマップも異なるバッチに含まれます。
* 一般に、ユニットあたり **約 25** テセルのライトマップ解像度で十分である必要があります ([照明/シーン] 設定で解像度を設定します)。  ライトマップに余分なスペースがある場合は、この値を増やします。
* オブジェクトごとに **Lightmap のスケーリング** 設定を変更して、必要なオブジェクトに対して解像度が保存されます。 

* **Lightmap スケーリング グラフ** (経験則) 
    * **Foreground** (Traversable level geo): 1 
    * **Props** (特に人間より小さい小さな小さな小さいプロパティ): **2 から 3** (オブジェクトのライトマップアーティファクトと継ぎ目を回避するために) 
    * **Midground** (トラバーサル可能な領域や建物のような大きなオブジェクトの外側にあるジオメトリ): **0.5**
    * **背景** (Vista/遠隔オブジェクト): **0.02** 
    * **透明サーフェス** (ガラスなど): **0 ('** キャスト/受信シャドウ' が無効になっている) 

また、ベースラインとして、Screen Door Effect 環境に使用されたいくつかの設定を次に示します。

![Unity の照明ウィンドウ](images/world-building-lightmaps.png)

注: これらの設定を使用している場合は、Lightmapper を "GPU Lightmapper" に設定し、プレビュー ベイクを高速化するために Lightmap Size を "2048" に設定し、最終的なベイクのために CPU と 4k にバックアップできます。

## <a name="texture-compressionfile-size"></a>**テクスチャ圧縮/ファイル サイズ**

* Android ビルドでは、Unity パッケージのシーン サイズを合計約 10 ~ 20 MB に維持します。  これを行うには、多くのオブジェクト間で汎用マテリアルを共有し、頂点の色を使用してオブジェクトを塗り分け、また、テクスチャで **ASTC 6x6** ブロック圧縮が使用される (既定の圧縮よりも小さく) Android の手動オーバーライドを設定します。

* ASTC を使用する Android ビルド設定を設定しない理由は、ライトマップが圧縮 (多数のブロックアーティファクト) で良く見えないので、ベイクの後に ETC を使用するライトマップを設定する必要があります。そのため、ベイク後にライトマップの圧縮設定を更新するよりも、すべてのシーン テクスチャに対してオーバーライドを 1 回設定する方が簡単です。

![Unity のテクスチャ ウィンドウ](images/world-building-texutres.png)

* また、[テクスチャ] を [Trilinear Filter Mode]/(三線フィルター モードと 2 つのレベルで)使用する設定を設定すると、角度を明るくしてシャープな状態を維持するのに役立ちます。

パフォーマンスに関するその他のヒントとテクニックについては、ワールド パフォーマンスの向上 [に関するドキュメントを参照してください](improving-performance.md)。
