---
title: AltspaceVR モバイル パフォーマンス ガイド
description: さまざまな Unity プロパティを使用して、Oculus Quest のようなモバイル デバイスで世界のパフォーマンスを高める方法について学習します
ms.date: 04/20/2021
ms.topic: article
keywords: ワールド エディター, パフォーマンス, oculus, quest, unity, テクスチャ, ライトマップ, 統計, プロファイラー, 描画呼び出し, altspacevr, アップデータ
ms.openlocfilehash: 9d6afba6fff85adfaa2ba290916f25c84c5377cd
ms.sourcegitcommit: 2db596ab5a1ecd4901a8c893741cc4d06f6aecea
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/25/2021
ms.locfileid: "112961261"
---
# <a name="altspacevr-mobile-performance-guide"></a><span data-ttu-id="e2937-104">AltspaceVR モバイル パフォーマンス ガイド</span><span class="sxs-lookup"><span data-stu-id="e2937-104">AltspaceVR Mobile Performance Guide</span></span>

## <a name="main-points"></a><span data-ttu-id="e2937-105">**主なポイント:**</span><span class="sxs-lookup"><span data-stu-id="e2937-105">**Main Points:**</span></span>

* <span data-ttu-id="e2937-106">Oculus Quest 1 および 2 の **72 FPS** がターゲットです。</span><span class="sxs-lookup"><span data-stu-id="e2937-106">**72 FPS** on Oculus Quest 1 and 2, is the target.</span></span>
* <span data-ttu-id="e2937-107">**静的バッチ処理による描画呼び出し** の削減は不可欠です **。25 未満の描画コールを目指します**</span><span class="sxs-lookup"><span data-stu-id="e2937-107">**Reducing Draw Calls via Static Batching** is essential, aim for **less than 25 drawcalls**</span></span>
* <span data-ttu-id="e2937-108">**静的バッチ処理を促進するために** 、オブジェクトごとに 1 つのマテリアル (マルチマテリアル オブジェクトを個別のオブジェクトに分割する)。</span><span class="sxs-lookup"><span data-stu-id="e2937-108">**One material per object** to encourage Static Batching (split up multi-material objects into separate objects).</span></span>
* <span data-ttu-id="e2937-109">**ほとんどの** 場合、環境内のオブジェクトは **'Static'** に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-109">**Objects** in an environment should be set to **‘Static’** in most cases.</span></span>
* <span data-ttu-id="e2937-110">**シーンごとに** 1 つのライトマップ、シーン全体に 1 つの 2K または 1 つの 4k、ユニットあたり約 25 のテセル、オブジェクトごとにライトマップのスケーリングを調整する必要があります (下のスケーリング チャート)</span><span class="sxs-lookup"><span data-stu-id="e2937-110">**One lightmap per scene**, one 2k or one 4k for the whole scene, ~25 texels per unit, lightmap scaling should be tuned per object (scaling chart below)</span></span>
* <span data-ttu-id="e2937-111">モバイル **品質** のシェーダー (つまり、"モバイル/拡散") を使用し、Unity 標準シェーダー/PBR/リフレクション プローブ/ライト プローブは操作が多く、プローブの場合は描画呼び出しが追加されます。</span><span class="sxs-lookup"><span data-stu-id="e2937-111">**Use Mobile-quality shaders** (that is, ‘Mobile/Diffuse’, etc.), avoid the Unity Standard shader/PBR/Reflection Probes/Light Probes as they are heavy operations and in the case of the probes will add draw calls.</span></span>
* <span data-ttu-id="e2937-112">**画面の三角形が 100,000** 未満</span><span class="sxs-lookup"><span data-stu-id="e2937-112">**Less than 100k triangles** on-screen</span></span>
* <span data-ttu-id="e2937-113">**オ** クルージョン カリングは画面の多角形を減らすのに役立ちますが、オクルージョン カリングを有効にした場合にコストがかかるので、診断パネルを使用して Altspace のフレームレートへの影響を測定します。</span><span class="sxs-lookup"><span data-stu-id="e2937-113">**Occlusion Culling** can help reduce on-screen polygons, although there is an up-front cost to having occlusion culling enabled so measure the effect on framerate in Altspace using the Diagnostics Panel.</span></span>
* <span data-ttu-id="e2937-114">シーン内 **のすべてのテクスチャに** 対して **、"Override for Android"** を使用し、 **それらを RGB(A) Compressed ASTC 6x6 ブロック形式に設定します**。</span><span class="sxs-lookup"><span data-stu-id="e2937-114">For all **textures** in a scene, use **‘Override for Android’** and set them to **RGB(A) Compressed ASTC 6x6 block format**.</span></span>  <span data-ttu-id="e2937-115">Android のビルド設定の圧縮を既定値のままにします (ファイル/ビルド設定/Android/テクスチャ圧縮: 'オーバーライドしない')。</span><span class="sxs-lookup"><span data-stu-id="e2937-115">Leave your Android Build Settings compression to default (found in: File/Build Settings/Android/Texture Compression: ‘Don’t override’), so that Lightmaps don’t get ASTC compression.</span></span>  <span data-ttu-id="e2937-116">上記を行い、オブジェクト間で素材を共有することで、シーンの Unity パッケージを Android 用 **の約 10 ~ 20 MB に維持します**。</span><span class="sxs-lookup"><span data-stu-id="e2937-116">By doing the above, and by sharing materials across objects, we try to keep our scene’s unity package to around **10-20 MB for Android**.</span></span>

<span data-ttu-id="e2937-117">一般的な目標は、デバイス間で許容されるフレームレートにヒットする方法です。Oculus Quest 1 と 2 では、シーンが設定されているときに、シーンがすべての見上げポイントから 72 FPS で実行されるのが理想的ですが、60 から 72 FPS の範囲は、多くの場合、より現実的なターゲットです。</span><span class="sxs-lookup"><span data-stu-id="e2937-117">The general goal is to hit an acceptable framerate across devices – on Oculus Quest 1 and 2 ideally the scene will run at 72 FPS from all vantage points when the scene is populated, although a range of 60-72 FPS is often a more realistic target.</span></span>

<span data-ttu-id="e2937-118">Framerate は、使用しているデバイスの AltspaceVR 内で測定できます (AltspaceVR アプリの [設定 **]/[サポート]/[診断パネル/FPS** の表示] で確認できます)。</span><span class="sxs-lookup"><span data-stu-id="e2937-118">Framerate can be measured within AltspaceVR on whichever device that you’re using (found in the AltspaceVR app under **Settings/Support/Show Diagnostics Panel/FPS**).</span></span>

<span data-ttu-id="e2937-119">シーンの最適化に役立つ標準の Unity ツールのランダウン:</span><span class="sxs-lookup"><span data-stu-id="e2937-119">A rundown of the standard Unity tools available to help you to better-optimize your scenes:</span></span>

## <a name="stats-panelframe-debuggerprofiler"></a><span data-ttu-id="e2937-120">**統計パネル/フレーム デバッガー/プロファイラー**</span><span class="sxs-lookup"><span data-stu-id="e2937-120">**Stats Panel/Frame Debugger/Profiler**</span></span>

* <span data-ttu-id="e2937-121">これらのツールは、シーンのパフォーマンスを向上させるのに最適な友人です。</span><span class="sxs-lookup"><span data-stu-id="e2937-121">These tools will be your best friends in improving your scene's performance.</span></span>  <span data-ttu-id="e2937-122">これらは、 **シーン** がエディター内で再生されている間にのみ参照できます。これは、シーンが再生されていないときとは値が異なる (つまり、シーンが再生されていないときに自動静的バッチ処理が実行されない) ので、</span><span class="sxs-lookup"><span data-stu-id="e2937-122">They can **only be referenced while the scene is Playing in-editor**, as their values will be different from when the scene is not playing (that is, Automatic static batching won't be happening when the scene isn't playing)</span></span>

* <span data-ttu-id="e2937-123">**統計パネル** ([統計] の下のゲーム ビューで表示可能) には、保存されたバッチ/バッチの量、SetPass 呼び出し、 **および Framerate が表示されます**。</span><span class="sxs-lookup"><span data-stu-id="e2937-123">**Stats Panel** (viewable in Game View under 'Stats') will show you the amount of **Batches/Batches Saved, SetPass Calls, and Framerate**.</span></span>

    * <span data-ttu-id="e2937-124">バッチ – 現在のカメラの観点から見た現在の描画呼び出しの量。</span><span class="sxs-lookup"><span data-stu-id="e2937-124">Batches – the amount of current draw calls that are visible from the current camera's perspective.</span></span>  <span data-ttu-id="e2937-125">**環境のバッチ数が 25** 未満の場合は、目標とするのが良いターゲットです。</span><span class="sxs-lookup"><span data-stu-id="e2937-125">**Fewer than 25 batches** for an environment is a good target to aim for.</span></span>
    * <span data-ttu-id="e2937-126">保存されたバッチ (シーンが再生されている場合にのみ表示) – 静的バッチ処理または GPU インスタンス化によって減少した描画呼び出しの **量**</span><span class="sxs-lookup"><span data-stu-id="e2937-126">Batches Saved (only visible when the scene is Playing)  – the amount draw calls that have been reduced via **Static Batching or GPU Instancing**</span></span>
    * <span data-ttu-id="e2937-127">SetPass 呼び出し – シーン内の異なる表示されるマテリアルの数</span><span class="sxs-lookup"><span data-stu-id="e2937-127">SetPass Calls – the number of different visible materials in a scene</span></span>
    * <span data-ttu-id="e2937-128">Framerate – ゲーム ビューの 1 秒あたりのフレームの量 (何が起こっているかをおおよそ知ることができます。シーンは常に、Oculus Framerate パネルを使用してアプリ内、ヘッドセット内でテストする必要があります。fps の読み取りはエディター内の読み取りとは常に異なります)</span><span class="sxs-lookup"><span data-stu-id="e2937-128">Framerate – the amount of frames-per-second in the Game view (gives you an approximate idea of what's happening; scenes should always be tested in-app, in-headset, using the Oculus Framerate panel as the fps readout will always be different than what's in-editor)</span></span>

* <span data-ttu-id="e2937-129">**フレーム デバッガー** ([ウィンドウ]/[分析]/[フレーム デバッガー]) の下に表示されます。</span><span class="sxs-lookup"><span data-stu-id="e2937-129">**Frame Debugger** (found under Window/Analysis/Frame Debugger).</span></span>  <span data-ttu-id="e2937-130">有効にすると、GPU が描画している画像を確認して最終的なイメージを作成し、最初から最後まで描画の一覧を表示できる、上の統計パネル。</span><span class="sxs-lookup"><span data-stu-id="e2937-130">The Stats Panel on steroids that, when enabled, will allow you to see what the GPU is drawing to create the final image, showing you a list of drawcalls from first to last.</span></span>  <span data-ttu-id="e2937-131">描画呼び出しが以前の描画呼び出しでバッチ処理されていない理由 (つまり、"このオブジェクトは別の素材を使用しています" または "このオブジェクトは別の Lightmap を使用しています") が得られるので、シーンで何が起こっているか、特定のビジュアルの選択肢が計算コストになる方法と理由の両方を理解するための優れた方法です。</span><span class="sxs-lookup"><span data-stu-id="e2937-131">It will give you reasons for why a draw call wasn't batched with a previous draw call (that is, 'This object uses a different Material' or 'This object uses a different Lightmap'), and is an excellent way towards developing an understanding both of what's happening in your scene, and how and why certain visual choices can be computationally expensive.</span></span>

* <span data-ttu-id="e2937-132">**プロファイラー** には、ゲームの実行中に任意の時点でコンピューターの使用されている部分が表示されます。</span><span class="sxs-lookup"><span data-stu-id="e2937-132">**Profiler** will show you what parts of the computer are being used at any point in time while the game is running.</span></span> <span data-ttu-id="e2937-133">パフォーマンスがボトルネックとなっている場所を特定する際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="e2937-133">Helpful in determining where performance is bottlenecking.</span></span>  <span data-ttu-id="e2937-134">たとえば、シーンで CPU 使用率が高い場合は、描画呼び出しが多すぎる可能性があります。また、GPU 使用率が高い場合は、過剰なオーバー描画が発生する可能性があります (つまり、1 ピクセルがレンダリングされ、最終的なイメージを生成する回数)。、または オブジェクトがビューから外れたときにカリングされない。</span><span class="sxs-lookup"><span data-stu-id="e2937-134">For instance, if you are seeing heavy CPU usage in your scene, it could be that there are too many draw calls, or if you're seeing heavy GPU usage, there might be too much overdraw happening (that is, the number of times that a single pixel is rendered to produce the final image) which can be caused by having multiple transparent surfaces, or objects not being culled when out of view.</span></span>

## <a name="draw-calls-shadersmaterialsobjects"></a><span data-ttu-id="e2937-135">**描画呼び出し (シェーダー/素材/オブジェクト)**</span><span class="sxs-lookup"><span data-stu-id="e2937-135">**Draw Calls (Shaders/Materials/Objects)**</span></span>

* <span data-ttu-id="e2937-136">シェーダー、素材、またはオブジェクトをレンダリングする必要があるたび、CPU はスイッチの GPU に指示する必要があります ("描画呼び出し"、口語的には **"drawcalls"** とも呼ばれています)。</span><span class="sxs-lookup"><span data-stu-id="e2937-136">Every time that a shader, material or object needs to be rendered, the CPU has to instruct the GPU of the switch (also known as 'draw calls', colloquially **'drawcalls'**).</span></span>  <span data-ttu-id="e2937-137">つまり、シェーダーが 5 つ、素材が 10、オブジェクトが 20 の場合は、どちらが最も大きい方になります。描画スケールは約 20 です。</span><span class="sxs-lookup"><span data-stu-id="e2937-137">That is, if you have 5 shaders, 10 materials, and 20 objects, with whichever is greatest; you'll have approximately 20 drawcalls.</span></span>  <span data-ttu-id="e2937-138">描画コールを乗算できるその他の点としては、異なるライトマップ上にオブジェクトを含めるか、シーン内に複数のリアルタイムライトを含める (つまり、1 つの点光によって、その範囲内にあるすべてのオブジェクトに別の描画コールが追加される) ことが含まれるので、通常、シーンの指向性ライト以外のものは避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-138">Other things that can multiply drawcalls include having objects on different lightmaps or having more than one real-time light in a scene (that is, one point light will add another drawcall to every object that is within its range), so generally anything other than a scene's directional light should be avoided.</span></span>  <span data-ttu-id="e2937-139">リフレクション プローブとライト プローブでは、ヒットしたオブジェクトに対する描画呼び出しも乗算されます。そのため、回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-139">Reflection probes and light probes will also multiply draw calls on whichever objects that they hit, so they should be avoided.</span></span>

* <span data-ttu-id="e2937-140">静的バッチ処理では、GPU に送信された場合に、同じ素材を共有するオブジェクトが 1 つのオブジェクトにバッチ処理されます (Occlusion Culling では、ビュー外のメッシュが破棄されます)。そのため、上の例のすべてのオブジェクトを "Static" に設定することで、シーンを約 10 の描画スケール (素材ごとに 1) に減らします。</span><span class="sxs-lookup"><span data-stu-id="e2937-140">**Static Batching** will batch objects that share like-materials into a single object when sent to the GPU (with Occlusion Culling discarding meshes that are out of view), so by setting all objects in the above example to 'Static', you would reduce the scene to approximately 10 drawcalls, 1 for every material.</span></span> 

* <span data-ttu-id="e2937-141">**素材バッチは** 、オブジェクトに別のオブジェクトとまったく同じ素材がある場合に発生しますが、オブジェクトに複数の素材がある場合、素材が少ないオブジェクトでバッチ処理は行われません。</span><span class="sxs-lookup"><span data-stu-id="e2937-141">**Material batches** occur when an object has the exact materials as another object, however if an object has multiple materials, it won't batch with an object that has fewer materials.</span></span>  <span data-ttu-id="e2937-142">このため、オブジェクトは **1** つの素材のみを含む必要があります。また、複数の素材を使用するオブジェクトは、素材ごとに個別のオブジェクトに分割する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-142">For this reason: **Objects MUST only have 1 material**, and objects that use several materials should be split into separate objects per material.</span></span>  <span data-ttu-id="e2937-143">**素材バッチは** 、 **テクスチャ Atlasing** を使用して削減できます (複数の一意のオブジェクトのテクスチャを組み合わせて 1 つのテクスチャ シートを共有し、すべてが同じマテリアルを使用します)。</span><span class="sxs-lookup"><span data-stu-id="e2937-143">**Material batches** can be reduced through **Texture Atlasing** (combining multiple unique object's textures to share a single texture sheet so that they all use the same material).</span></span>  <span data-ttu-id="e2937-144">可能であれば、Atlases の量をシーンごとに 1 つの 2k または 4k のテクスチャ/マテリアルに減らしてみてください。</span><span class="sxs-lookup"><span data-stu-id="e2937-144">Try to keep the amount of Atlases down to a single 2k or 4k texture/material per scene if possible.</span></span>

## <a name="scene-complexity"></a><span data-ttu-id="e2937-145">**シーンの複雑さ**</span><span class="sxs-lookup"><span data-stu-id="e2937-145">**Scene Complexity**</span></span>

* <span data-ttu-id="e2937-146">**Geometry** – 環境の画面の三角形を 100,000 以下に保ちます。</span><span class="sxs-lookup"><span data-stu-id="e2937-146">**Geometry** – try to keep onscreen triangles for environments below 100k.</span></span>  <span data-ttu-id="e2937-147">Unity の [ゲーム] パネルの [統計] タブを使用して、シーン内のさまざまな見えるポイントからヒットしている三角形のカウントを確認します。</span><span class="sxs-lookup"><span data-stu-id="e2937-147">Use the ‘Stats’ tab in Unity’s Game panel to see what triangle counts you’re hitting from various vantage points in the scene.</span></span>  <span data-ttu-id="e2937-148">このような Prop は、数百の三角形の範囲に含む必要があります。重要な 'hero' props は、数千の三角形の範囲に含む必要があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-148">Props as such should be in the ‘hundreds’ of triangles range, with only important ‘hero’ props in the thousands of triangles range.</span></span> 

* <span data-ttu-id="e2937-149">技術的には **LOD** (詳細メッシュのレベル) を使用できます。ただし、Unity の既定のライトマップ ソリューションは LOD 間でライトマップ データを共有しないので、この解像度で LOD が切り替えるときにライトマップアーティファクトを取得できます。</span><span class="sxs-lookup"><span data-stu-id="e2937-149">You can technically use **LODs** (level of detail meshes), although Unity’s default lightmap solution does not share lightmap data between LODs, so you may get lightmapping artifacts when the LODs switch at this resolution.</span></span>  <span data-ttu-id="e2937-150">または、オブジェクトの LOD メッシュが低い場合でも、単純な距離カリングに LOD グループ コンポーネントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="e2937-150">Alternatively, you can use the LOD Group component for simple Distance Culling, even if the object doesn’t have lower LOD meshes:</span></span>

![Unity の LOD グループ ウィンドウ](images/world-building-lod-Group.png)

* <span data-ttu-id="e2937-152">**オクルー** ジョン カリングを使用すると、カメラのビューの frustum 内にあるものにのみレンダリングされ、すぐに表示されるオブジェクトの数が減ります (つまり、ビューからオクルードされているオブジェクトは Culled になります)。</span><span class="sxs-lookup"><span data-stu-id="e2937-152">**Occlusion Culling** reduces the number of objects that are rendered to only what is within the camera's view frustum, and that are immediately visible (that is, objects that are Occluded from view are Culled).</span></span>  <span data-ttu-id="e2937-153">オクルージョン カリングはほぼ常にシーン用にベイクする必要があります。また、それをサポートするようにレベルを設計する必要があります (つまり、大きなレベルを持っている場合は、壁や大きなオブジェクトを使用してプレーヤーの視線を壊し、常にレベルの反対側まで見抜け出す必要はありません)。</span><span class="sxs-lookup"><span data-stu-id="e2937-153">Occlusion culling should almost always be baked for your scene, and levels should be designed to support it (that is, if you have a large level, walls or large objects can be used to break up the player's line-of-sight, so that they can't always see through to the opposite end of the level.</span></span>  <span data-ttu-id="e2937-154">既定のベイク設定は機能しますが、"Smallest Occluder" または "Smallest Hole" の値を縮小する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-154">The default bake settings should work, although you may have to shrink the 'Smallest Occluder' or 'Smallest Hole' values.</span></span>  <span data-ttu-id="e2937-155">オブジェクトの割れ目を確認できる可能性があるフェンスや透明なオブジェクトのようなオブジェクトの場合は、[静的] ドロップダウン メニューでオブジェクトの 'Occluder' 状態をオフにし、背後にあるオブジェクトが誤って隠れ込むのを防ぐことが必要です。</span><span class="sxs-lookup"><span data-stu-id="e2937-155">For objects like fences where you may be able to see through cracks in the object, or transparent objects, you should turn off the object's 'Occluder' status in the 'Static' drop-down menu so that objects behind it aren't erroneously occluded.</span></span> 

## <a name="lightmaps"></a><span data-ttu-id="e2937-156">**ライトマップ**</span><span class="sxs-lookup"><span data-stu-id="e2937-156">**Lightmaps**</span></span>

* <span data-ttu-id="e2937-157">ない場合は **、シーンごとに 1** つのライトマップ (1 つの 2k または 1 つの 4k) が理想的です。より低い解像度の多くのライトマップよりも、より高い解像度のライトマップが少ない方が優れた場合があります。</span><span class="sxs-lookup"><span data-stu-id="e2937-157">Ideally just **one lightmap per scene** (one 2k or one 4k for everything), if not; fewer lightmaps of higher resolutions are better than many lightmaps of lower resolutions.</span></span>
* <span data-ttu-id="e2937-158">複数のライトマップを使用すると、描画呼び出しの数にも影響を与える可能性があります。ライトマップを持つオブジェクトまたはないオブジェクトは異なるバッチ上に表示され、他のライトマップも異なるバッチに含まれます。</span><span class="sxs-lookup"><span data-stu-id="e2937-158">Having multiple lightmaps can also affect the number of draw calls, as objects that either have or don't have lightmaps will be on different batches, and other lightmaps will also be on different batches.</span></span>
* <span data-ttu-id="e2937-159">一般に、ユニットあたり **約 25** テセルのライトマップ解像度で十分です ([ライト/シーン] 設定で解像度を設定します)。</span><span class="sxs-lookup"><span data-stu-id="e2937-159">Generally, a Lightmap Resolution of around **25 texels per unit** should suffice (set resolution in the Lighting/Scene settings).</span></span>  <span data-ttu-id="e2937-160">ライトマップに余分なスペースがある場合は、この値を増やします。</span><span class="sxs-lookup"><span data-stu-id="e2937-160">If you have extra room in your lightmap, you can increase this value.</span></span>
* <span data-ttu-id="e2937-161">オブジェクトごとに **Lightmap のスケーリング** 設定を変更して、必要なオブジェクトに対して解像度が保存されます。</span><span class="sxs-lookup"><span data-stu-id="e2937-161">Change the **Lightmap Scaling** setting per object so that the resolution is saved for objects that need it.</span></span> 

* <span data-ttu-id="e2937-162">**Lightmap スケーリング グラフ** (経験則)</span><span class="sxs-lookup"><span data-stu-id="e2937-162">**Lightmap Scaling Chart** (rule of thumb)</span></span> 
    * <span data-ttu-id="e2937-163">**フォア** グラウンド (トラバーサル可能レベル geo): 1</span><span class="sxs-lookup"><span data-stu-id="e2937-163">**Foreground** (Traversable level geo): 1</span></span> 
    * <span data-ttu-id="e2937-164">**Props** (特に人間より小さい小さなプロパティ): **2 から 3** (オブジェクトのライトマップアーティファクトと継ぎ目を避けるため)</span><span class="sxs-lookup"><span data-stu-id="e2937-164">**Props** (especially props smaller than a human): **2-3** (to avoid lightmap artifacts and seams on your objects)</span></span> 
    * <span data-ttu-id="e2937-165">**Midground** (トラバーサル可能な領域や建物のような大きなオブジェクトの外側にあるジオメトリ): **0.5**</span><span class="sxs-lookup"><span data-stu-id="e2937-165">**Midground** (Geometry that is just outside of the traversable area and/or large objects like buildings): **0.5**</span></span>
    * <span data-ttu-id="e2937-166">**背景** (Vista/遠隔オブジェクト): **0.02**</span><span class="sxs-lookup"><span data-stu-id="e2937-166">**Background** (Vista/distant objects): **0.02**</span></span> 
    * <span data-ttu-id="e2937-167">**透明サーフェス** (ガラスなど): **0 ('** キャスト/受信シャドウ' が無効になっている)</span><span class="sxs-lookup"><span data-stu-id="e2937-167">**Transparent Surfaces** (like glass): **0** (with 'Cast/Receive Shadows’ disabled)</span></span> 

<span data-ttu-id="e2937-168">また、ベースラインとして、Screen Door Effect 環境に使用されたいくつかの設定を次に示します。</span><span class="sxs-lookup"><span data-stu-id="e2937-168">Also, as a baseline, here are some settings that were used for the Screen Door Effect environment:</span></span>

![Unity の照明ウィンドウ](images/world-building-lightmaps.png)

## <a name="texture-compressionfile-size"></a><span data-ttu-id="e2937-170">**テクスチャ圧縮/ファイル サイズ**</span><span class="sxs-lookup"><span data-stu-id="e2937-170">**Texture Compression/File Size**</span></span>

* <span data-ttu-id="e2937-171">Android ビルドでは、Unity パッケージのシーン サイズを合計約 10 ~ 20 MB に維持します。</span><span class="sxs-lookup"><span data-stu-id="e2937-171">For our Android build, we try to keep our Unity package scene size down to around 10-20 MB total.</span></span>  <span data-ttu-id="e2937-172">これを行うには、多くのオブジェクト間で汎用マテリアルを共有し、頂点の色を使用してオブジェクトを塗り分け、また、テクスチャで **ASTC 6x6** ブロック圧縮が使用され、既定の圧縮よりも小さくなる Android の手動オーバーライドを設定します。</span><span class="sxs-lookup"><span data-stu-id="e2937-172">We do this by sharing generic materials across many objects, using vertex color to tint the objects, and also by setting manual overrides for Android so that textures use **ASTC 6x6 block compression**, which will be smaller than the default compression.</span></span>

* <span data-ttu-id="e2937-173">ASTC を使用する Android ビルド設定を設定しない理由は、ライトマップが圧縮 (多数のブロックアーティファクト) で良く見えず、ベイク後に ETC を使用するライトマップを設定する必要があるためです。そのため、ベイク後にライトマップの圧縮設定を更新するよりも、すべてのシーン テクスチャに対してオーバーライドを 1 回設定する方が簡単です。</span><span class="sxs-lookup"><span data-stu-id="e2937-173">The reason that we don't set the Android build settings to use ASTC is because lightmaps do not look good with that compression (lots of blocky artifacts), and we’d have to set the lightmap to use ETC after every bake, so it is easier instead to set up the override for all scene textures once than it is to update the lightmap’s compression settings after every bake.</span></span>

![Unity のテクスチャ ウィンドウ](images/world-building-texutres.png)

* <span data-ttu-id="e2937-175">また、[テクスチャ] を [Trilinear Filter Mode]/(三線フィルター モードと 2 つのレベルで)使用する設定を設定すると、角度を明るくしてシャープな状態を維持するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="e2937-175">Also, setting Textures to use Trilinear Filter Mode with a 2 Anisotropic Level can help them remain sharp at glancing angles.</span></span>

<span data-ttu-id="e2937-176">パフォーマンスに関するその他のヒントとテクニックについては、ワールド パフォーマンスの [向上に関するドキュメントを参照してください](improving-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="e2937-176">More performance tips and tricks can be found in the [Improving world performance documentation](improving-performance.md).</span></span>