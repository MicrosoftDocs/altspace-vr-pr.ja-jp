---
title: AltspaceVR モバイル パフォーマンス ガイド
description: さまざまな Unity プロパティを使用して、Oculus Quest のようなモバイル デバイスで世界のパフォーマンスを高める方法について学習します
ms.date: 04/20/2021
ms.topic: article
keywords: ワールド エディター, パフォーマンス, oculus, quest, unity, テクスチャ, ライトマップ, 統計, プロファイラー, 描画呼び出し, altspacevr, アップデータ
ms.openlocfilehash: 9d6afba6fff85adfaa2ba290916f25c84c5377cd
ms.sourcegitcommit: 2db596ab5a1ecd4901a8c893741cc4d06f6aecea
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/25/2021
ms.locfileid: "112961261"
---
# <a name="altspacevr-mobile-performance-guide"></a>AltspaceVR モバイル パフォーマンス ガイド

## <a name="main-points"></a>**主なポイント:**

* Oculus Quest 1 および 2 の **72 FPS** がターゲットです。
* **静的バッチ処理による描画呼び出し** の削減は不可欠です **。25 未満の描画コールを目指します**
* **静的バッチ処理を促進するために** 、オブジェクトごとに 1 つのマテリアル (マルチマテリアル オブジェクトを個別のオブジェクトに分割する)。
* **ほとんどの** 場合、環境内のオブジェクトは **'Static'** に設定する必要があります。
* **シーンごとに** 1 つのライトマップ、シーン全体に 1 つの 2K または 1 つの 4k、ユニットあたり約 25 のテセル、オブジェクトごとにライトマップのスケーリングを調整する必要があります (下のスケーリング チャート)
* モバイル **品質** のシェーダー (つまり、"モバイル/拡散") を使用し、Unity 標準シェーダー/PBR/リフレクション プローブ/ライト プローブは操作が多く、プローブの場合は描画呼び出しが追加されます。
* **画面の三角形が 100,000** 未満
* **オ** クルージョン カリングは画面の多角形を減らすのに役立ちますが、オクルージョン カリングを有効にした場合にコストがかかるので、診断パネルを使用して Altspace のフレームレートへの影響を測定します。
* シーン内 **のすべてのテクスチャに** 対して **、"Override for Android"** を使用し、 **それらを RGB(A) Compressed ASTC 6x6 ブロック形式に設定します**。  Android のビルド設定の圧縮を既定値のままにします (ファイル/ビルド設定/Android/テクスチャ圧縮: 'オーバーライドしない')。  上記を行い、オブジェクト間で素材を共有することで、シーンの Unity パッケージを Android 用 **の約 10 ~ 20 MB に維持します**。

一般的な目標は、デバイス間で許容されるフレームレートにヒットする方法です。Oculus Quest 1 と 2 では、シーンが設定されているときに、シーンがすべての見上げポイントから 72 FPS で実行されるのが理想的ですが、60 から 72 FPS の範囲は、多くの場合、より現実的なターゲットです。

Framerate は、使用しているデバイスの AltspaceVR 内で測定できます (AltspaceVR アプリの [設定 **]/[サポート]/[診断パネル/FPS** の表示] で確認できます)。

シーンの最適化に役立つ標準の Unity ツールのランダウン:

## <a name="stats-panelframe-debuggerprofiler"></a>**統計パネル/フレーム デバッガー/プロファイラー**

* これらのツールは、シーンのパフォーマンスを向上させるのに最適な友人です。  これらは、 **シーン** がエディター内で再生されている間にのみ参照できます。これは、シーンが再生されていないときとは値が異なる (つまり、シーンが再生されていないときに自動静的バッチ処理が実行されない) ので、

* **統計パネル** ([統計] の下のゲーム ビューで表示可能) には、保存されたバッチ/バッチの量、SetPass 呼び出し、 **および Framerate が表示されます**。

    * バッチ – 現在のカメラの観点から見た現在の描画呼び出しの量。  **環境のバッチ数が 25** 未満の場合は、目標とするのが良いターゲットです。
    * 保存されたバッチ (シーンが再生されている場合にのみ表示) – 静的バッチ処理または GPU インスタンス化によって減少した描画呼び出しの **量**
    * SetPass 呼び出し – シーン内の異なる表示されるマテリアルの数
    * Framerate – ゲーム ビューの 1 秒あたりのフレームの量 (何が起こっているかをおおよそ知ることができます。シーンは常に、Oculus Framerate パネルを使用してアプリ内、ヘッドセット内でテストする必要があります。fps の読み取りはエディター内の読み取りとは常に異なります)

* **フレーム デバッガー** ([ウィンドウ]/[分析]/[フレーム デバッガー]) の下に表示されます。  有効にすると、GPU が描画している画像を確認して最終的なイメージを作成し、最初から最後まで描画の一覧を表示できる、上の統計パネル。  描画呼び出しが以前の描画呼び出しでバッチ処理されていない理由 (つまり、"このオブジェクトは別の素材を使用しています" または "このオブジェクトは別の Lightmap を使用しています") が得られるので、シーンで何が起こっているか、特定のビジュアルの選択肢が計算コストになる方法と理由の両方を理解するための優れた方法です。

* **プロファイラー** には、ゲームの実行中に任意の時点でコンピューターの使用されている部分が表示されます。 パフォーマンスがボトルネックとなっている場所を特定する際に役立ちます。  たとえば、シーンで CPU 使用率が高い場合は、描画呼び出しが多すぎる可能性があります。また、GPU 使用率が高い場合は、過剰なオーバー描画が発生する可能性があります (つまり、1 ピクセルがレンダリングされ、最終的なイメージを生成する回数)。、または オブジェクトがビューから外れたときにカリングされない。

## <a name="draw-calls-shadersmaterialsobjects"></a>**描画呼び出し (シェーダー/素材/オブジェクト)**

* シェーダー、素材、またはオブジェクトをレンダリングする必要があるたび、CPU はスイッチの GPU に指示する必要があります ("描画呼び出し"、口語的には **"drawcalls"** とも呼ばれています)。  つまり、シェーダーが 5 つ、素材が 10、オブジェクトが 20 の場合は、どちらが最も大きい方になります。描画スケールは約 20 です。  描画コールを乗算できるその他の点としては、異なるライトマップ上にオブジェクトを含めるか、シーン内に複数のリアルタイムライトを含める (つまり、1 つの点光によって、その範囲内にあるすべてのオブジェクトに別の描画コールが追加される) ことが含まれるので、通常、シーンの指向性ライト以外のものは避ける必要があります。  リフレクション プローブとライト プローブでは、ヒットしたオブジェクトに対する描画呼び出しも乗算されます。そのため、回避する必要があります。

* 静的バッチ処理では、GPU に送信された場合に、同じ素材を共有するオブジェクトが 1 つのオブジェクトにバッチ処理されます (Occlusion Culling では、ビュー外のメッシュが破棄されます)。そのため、上の例のすべてのオブジェクトを "Static" に設定することで、シーンを約 10 の描画スケール (素材ごとに 1) に減らします。 

* **素材バッチは** 、オブジェクトに別のオブジェクトとまったく同じ素材がある場合に発生しますが、オブジェクトに複数の素材がある場合、素材が少ないオブジェクトでバッチ処理は行われません。  このため、オブジェクトは **1** つの素材のみを含む必要があります。また、複数の素材を使用するオブジェクトは、素材ごとに個別のオブジェクトに分割する必要があります。  **素材バッチは** 、 **テクスチャ Atlasing** を使用して削減できます (複数の一意のオブジェクトのテクスチャを組み合わせて 1 つのテクスチャ シートを共有し、すべてが同じマテリアルを使用します)。  可能であれば、Atlases の量をシーンごとに 1 つの 2k または 4k のテクスチャ/マテリアルに減らしてみてください。

## <a name="scene-complexity"></a>**シーンの複雑さ**

* **Geometry** – 環境の画面の三角形を 100,000 以下に保ちます。  Unity の [ゲーム] パネルの [統計] タブを使用して、シーン内のさまざまな見えるポイントからヒットしている三角形のカウントを確認します。  このような Prop は、数百の三角形の範囲に含む必要があります。重要な 'hero' props は、数千の三角形の範囲に含む必要があります。 

* 技術的には **LOD** (詳細メッシュのレベル) を使用できます。ただし、Unity の既定のライトマップ ソリューションは LOD 間でライトマップ データを共有しないので、この解像度で LOD が切り替えるときにライトマップアーティファクトを取得できます。  または、オブジェクトの LOD メッシュが低い場合でも、単純な距離カリングに LOD グループ コンポーネントを使用できます。

![Unity の LOD グループ ウィンドウ](images/world-building-lod-Group.png)

* **オクルー** ジョン カリングを使用すると、カメラのビューの frustum 内にあるものにのみレンダリングされ、すぐに表示されるオブジェクトの数が減ります (つまり、ビューからオクルードされているオブジェクトは Culled になります)。  オクルージョン カリングはほぼ常にシーン用にベイクする必要があります。また、それをサポートするようにレベルを設計する必要があります (つまり、大きなレベルを持っている場合は、壁や大きなオブジェクトを使用してプレーヤーの視線を壊し、常にレベルの反対側まで見抜け出す必要はありません)。  既定のベイク設定は機能しますが、"Smallest Occluder" または "Smallest Hole" の値を縮小する必要がある場合があります。  オブジェクトの割れ目を確認できる可能性があるフェンスや透明なオブジェクトのようなオブジェクトの場合は、[静的] ドロップダウン メニューでオブジェクトの 'Occluder' 状態をオフにし、背後にあるオブジェクトが誤って隠れ込むのを防ぐことが必要です。 

## <a name="lightmaps"></a>**ライトマップ**

* ない場合は **、シーンごとに 1** つのライトマップ (1 つの 2k または 1 つの 4k) が理想的です。より低い解像度の多くのライトマップよりも、より高い解像度のライトマップが少ない方が優れた場合があります。
* 複数のライトマップを使用すると、描画呼び出しの数にも影響を与える可能性があります。ライトマップを持つオブジェクトまたはないオブジェクトは異なるバッチ上に表示され、他のライトマップも異なるバッチに含まれます。
* 一般に、ユニットあたり **約 25** テセルのライトマップ解像度で十分です ([ライト/シーン] 設定で解像度を設定します)。  ライトマップに余分なスペースがある場合は、この値を増やします。
* オブジェクトごとに **Lightmap のスケーリング** 設定を変更して、必要なオブジェクトに対して解像度が保存されます。 

* **Lightmap スケーリング グラフ** (経験則) 
    * **フォア** グラウンド (トラバーサル可能レベル geo): 1 
    * **Props** (特に人間より小さい小さなプロパティ): **2 から 3** (オブジェクトのライトマップアーティファクトと継ぎ目を避けるため) 
    * **Midground** (トラバーサル可能な領域や建物のような大きなオブジェクトの外側にあるジオメトリ): **0.5**
    * **背景** (Vista/遠隔オブジェクト): **0.02** 
    * **透明サーフェス** (ガラスなど): **0 ('** キャスト/受信シャドウ' が無効になっている) 

また、ベースラインとして、Screen Door Effect 環境に使用されたいくつかの設定を次に示します。

![Unity の照明ウィンドウ](images/world-building-lightmaps.png)

## <a name="texture-compressionfile-size"></a>**テクスチャ圧縮/ファイル サイズ**

* Android ビルドでは、Unity パッケージのシーン サイズを合計約 10 ~ 20 MB に維持します。  これを行うには、多くのオブジェクト間で汎用マテリアルを共有し、頂点の色を使用してオブジェクトを塗り分け、また、テクスチャで **ASTC 6x6** ブロック圧縮が使用され、既定の圧縮よりも小さくなる Android の手動オーバーライドを設定します。

* ASTC を使用する Android ビルド設定を設定しない理由は、ライトマップが圧縮 (多数のブロックアーティファクト) で良く見えず、ベイク後に ETC を使用するライトマップを設定する必要があるためです。そのため、ベイク後にライトマップの圧縮設定を更新するよりも、すべてのシーン テクスチャに対してオーバーライドを 1 回設定する方が簡単です。

![Unity のテクスチャ ウィンドウ](images/world-building-texutres.png)

* また、[テクスチャ] を [Trilinear Filter Mode]/(三線フィルター モードと 2 つのレベルで)使用する設定を設定すると、角度を明るくしてシャープな状態を維持するのに役立ちます。

パフォーマンスに関するその他のヒントとテクニックについては、ワールド パフォーマンスの [向上に関するドキュメントを参照してください](improving-performance.md)。